<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>문장 순서 맞추기</title>

  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Google Fonts for Nanum Gothic -->
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Nanum+Gothic:wght@400;700;800&display=swap');
    body {
      font-family: 'Nanum Gothic', sans-serif;
    }

    /* 기본 컨테이너 스타일 */
    .container {
        min-height: 80px;
        border: 2px dashed #ccc;
        margin-bottom: 20px;
        padding: 10px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
    }

    /* 문장 조각 스타일 */
    .sentence-piece {
        cursor: grab;
        user-select: none;
    }

    /* 드래그 중인 요소 스타일 */
    .is-dragging {
        opacity: 0.5;
        border-style: dashed !important;
    }

    /* 피드백 아이콘 애니메이션 */
    @keyframes pulse {
        0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
        50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
    }
    .animate-pulse {
        animation: pulse 1s infinite;
    }

    /* 오답 bounce (위치 고정 버전) */
    @keyframes bounce-fixed {
        0%, 20%, 50%, 80%, 100% {
          transform: translate(-50%, -50%) translateY(0);
          opacity: 0.8;
        }
        40% { transform: translate(-50%, -50%) translateY(-10px); }
        60% { transform: translate(-50%, -50%) translateY(-5px); }
    }
    .bounce-fixed {
        animation: bounce-fixed 1s infinite;
    }

    /* 오답 시 흔들림 애니메이션 */
    @keyframes shake {
        0%, 100% { transform: translateX(0); }
        10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
        20%, 40%, 60%, 80% { transform: translateX(5px); }
    }
    .shake {
        animation: shake 0.5s ease-in-out;
    }
  </style>
</head>
<body class="bg-[#FBF9F2] min-h-screen flex flex-col items-center p-4">

<h1 class="text-4xl font-extrabold text-[#2F4160] mb-8 mt-12">🧩 문장 순서 맞추기</h1>

<div class="bg-white rounded-2xl shadow-xl p-8 w-full max-w-2xl flex flex-col items-center space-y-6">

  <!-- 지시문 -->
  <p class="text-lg text-[#2F4160] font-semibold text-center leading-relaxed">
    아래 문장 조각들을 드래그하여 올바른 순서로 배열하세요.
  </p>

  <!-- 드래그 가능한 조각들이 있는 컨테이너 -->
  <div id="shuffled-container"
       class="min-h-[80px] w-full border-2 border-dashed border-[#B5D0E3] rounded-lg p-3 flex flex-wrap gap-2 justify-center bg-gray-50 shadow-inner">
  </div>

  <!-- 구분선 -->
  <hr class="w-full border-t-2 border-gray-200 my-4">

  <!-- 사용자가 정렬할 컨테이너 -->
  <div id="sorted-container"
       class="min-h-[80px] w-full border-2 border-dashed border-[#F29DA0] rounded-lg p-3 flex flex-wrap gap-2 justify-center bg-gray-50 shadow-inner">
  </div>

  <div class="flex gap-4">
    <button id="check-button"
            class="bg-[#F29DA0] text-white px-8 py-3 rounded-xl font-bold text-lg hover:bg-[#2F4160] transition duration-300 transform hover:scale-105 shadow-md">
      정답 확인
    </button>
    <button id="next-problem-button" style="display: none;"
            class="bg-[#B5D0E3] text-[#2F4160] px-8 py-3 rounded-xl font-bold text-lg hover:bg-[#2F4160] hover:text-white transition duration-300 transform hover:scale-105 shadow-md">
      다음 문제
    </button>
  </div>

  <p id="result-message" class="text-xl font-bold mt-4 text-[#2F4160] text-center"></p>

</div>

<!-- 피드백 아이콘 (O/X) -->
<div id="feedback-icon" class="hidden text-9xl font-bold fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 opacity-80 z-10"></div>


<div class="fixed bottom-6 right-6">
  <button onclick="quitLesson()"
          class="bg-gray-500 text-white px-6 py-3 rounded-xl font-bold text-lg hover:bg-gray-700 transition duration-300 transform hover:scale-105 shadow-lg">
    그만 하기
  </button>
</div>

<script>
  // Custom message box function
  function showCustomMessage(message, type = 'info') {
      const messageBox = document.createElement('div');
      messageBox.textContent = message;
      let bgColor = '#2F4160';
      let textColor = 'white';

      if (type === 'error') {
          bgColor = '#F29DA0';
      }

      messageBox.style.cssText = `
          position: fixed;
          top: 20%;
          left: 50%;
          transform: translate(-50%, -50%);
          background-color: ${bgColor};
          color: ${textColor};
          padding: 15px 30px;
          border-radius: 8px;
          z-index: 1000;
          font-size: 1.1em;
          box-shadow: 0 4px 10px rgba(0,0,0,0.2);
          animation: fadeOut 3s forwards;
      `;
      document.body.appendChild(messageBox);

      const styleSheet = document.createElement("style");
      styleSheet.type = "text/css";
      styleSheet.innerText = `
          @keyframes fadeOut {
              0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
              100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
          }
      `;
      document.head.appendChild(styleSheet);

      setTimeout(() => {
          messageBox.remove();
          if (styleSheet.parentNode) {
              styleSheet.parentNode.removeChild(styleSheet);
          }
      }, 3000);
  }

  document.addEventListener('DOMContentLoaded', function() {
      loadNewProblem();

      document.getElementById('check-button').addEventListener('click', checkAnswer);
      document.getElementById('next-problem-button').addEventListener('click', loadNewProblem);

      const containers = document.querySelectorAll('#shuffled-container, #sorted-container');
      containers.forEach(container => {
          container.addEventListener('dragover', e => {
              e.preventDefault();
              const draggable = document.querySelector('.is-dragging');
              const afterElement = getDragAfterElement(container, e.clientX);
              if (afterElement == null) {
                  container.appendChild(draggable);
              } else {
                  container.insertBefore(draggable, afterElement);
              }
          });
      });
  });

  function loadNewProblem() {
      document.getElementById('feedback-icon').classList.add('hidden');
      document.getElementById('next-problem-button').style.display = 'none';
      document.getElementById('check-button').style.display = 'block';
      document.getElementById('result-message').textContent = '';

      const shuffledContainer = document.getElementById('shuffled-container');
      shuffledContainer.innerHTML = '';
      document.getElementById('sorted-container').innerHTML = '';

      fetch('/study/api/get-lesson2-sentence')
          .then(response => response.json())
          .then(data => {
              if (data.error) {
                  showCustomMessage(data.error, 'error');
                  return;
              }
              displayPieces(data.pieces);
          })
          .catch(error => {
              console.error('Error loading problem:', error);
              showCustomMessage('문제 로딩에 실패했습니다.', 'error');
          });
  }

  function displayPieces(pieces) {
      const shuffledContainer = document.getElementById('shuffled-container');
      shuffledContainer.innerHTML = '';

      pieces.forEach(pieceText => {
          const pieceDiv = document.createElement('div');
          pieceDiv.className = 'sentence-piece bg-white text-[#2F4160] px-4 py-2 rounded-lg shadow-md border border-gray-200 transition-all duration-200 hover:scale-105';
          pieceDiv.textContent = pieceText;
          pieceDiv.setAttribute('draggable', true);

          pieceDiv.addEventListener('dragstart', () => {
              pieceDiv.classList.add('is-dragging');
          });

          pieceDiv.addEventListener('dragend', () => {
              pieceDiv.classList.remove('is-dragging');
          });

          shuffledContainer.appendChild(pieceDiv);
      });
  }

  function checkAnswer() {
      const userPieces = Array.from(document.getElementById('sorted-container').children)
                              .map(el => el.textContent);

      if (userPieces.length === 0) {
          showCustomMessage('먼저 문장 조각을 배치해주세요.', 'error');
          return;
      }

      fetch('/study/api/check-lesson2-answer', {
          method: 'POST',
          headers: {
              'Content-Type': 'application/json'
          },
          body: JSON.stringify({ userPieces: userPieces })
      })
      .then(response => response.json())
      .then(data => {
          const feedbackIcon = document.getElementById('feedback-icon');
          const nextButton = document.getElementById('next-problem-button');
          const sortedContainer = document.getElementById('sorted-container');
          const checkButton = document.getElementById('check-button');

          if (data.isCorrect) {
              feedbackIcon.textContent = '✔️';
              feedbackIcon.className = 'fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-9xl font-bold opacity-80 text-[#2F4160] animate-pulse';
              feedbackIcon.classList.remove('hidden');

              nextButton.style.display = 'block';
              checkButton.style.display = 'none';
              document.getElementById('result-message').textContent = '정답입니다! 다음 문제로 넘어갈 수 있습니다.';

              setTimeout(() => { feedbackIcon.classList.add('hidden'); }, 1500);
          } else {
          if (data.message.includes('3번 틀렸습니다.')) {
            feedbackIcon.textContent = '❌';
            feedbackIcon.className =
              'fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 ' +
              'text-9xl font-bold opacity-80 text-[#F29DA0] bounce-fixed';
            feedbackIcon.classList.remove('hidden');

            nextButton.style.display = 'block';
            checkButton.style.display = 'none';
            document.getElementById('result-message').textContent = data.message;

            setTimeout(() => { feedbackIcon.classList.add('hidden'); }, 1500);

            } else {
                  sortedContainer.classList.add('shake');
                  sortedContainer.addEventListener('animationend', () => {
                      sortedContainer.classList.remove('shake');
                      const shuffledContainer = document.getElementById('shuffled-container');
                      while(sortedContainer.firstChild) {
                          shuffledContainer.appendChild(sortedContainer.firstChild);
                      }
                  }, { once: true });
                  document.getElementById('result-message').textContent = data.message;
              }
          }
      })
      .catch(error => {
          console.error('Error checking answer:', error);
          showCustomMessage('정답 확인 중 오류가 발생했습니다.', 'error');
      });
  }

  function getDragAfterElement(container, x) {
      const draggableElements = [...container.querySelectorAll('.sentence-piece:not(.is-dragging)')];
      return draggableElements.reduce((closest, child) => {
          const box = child.getBoundingClientRect();
          const offset = x - box.left - box.width / 2;
          if (offset < 0 && offset > closest.offset) {
              return { offset: offset, element: child };
          } else {
              return closest;
          }
      }, { offset: Number.NEGATIVE_INFINITY }).element;
  }

 function quitLesson() {
            // window.opener가 있다면 (팝업 창으로 열렸다면) 창 닫기
            if (window.opener) {
                window.close();
            } else {
                // 직접 브라우저에서 열렸다면 메시지 표시 (alert 대신 커스텀 모달)
                const messageBox = document.createElement('div');
                messageBox.textContent = "이 창은 브라우저에서 직접 열렸기 때문에 자동으로 닫을 수 없습니다.";
                messageBox.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background-color: #2F4160; /* 진한 남색 */
                    color: white;
                    padding: 20px;
                    border-radius: 10px;
                    z-index: 1000;
                    font-size: 1.2em;
                    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
                `;
                document.body.appendChild(messageBox);

                // 3초 후 메시지 박스 제거
                setTimeout(() => {
                    messageBox.remove();
                }, 3000);
            }
        }

</script>
</body>
</html>
